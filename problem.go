package problem

import (
	"encoding/json"
	"errors"
	"strings"
	"sync/atomic"
)

type Problem interface {
	Problem() ProblemInfo
}

// ProblemInfo is the struct definition of a problem details object as defined by
// the RFC7807.
type ProblemInfo struct {
	//   Type is a URI reference [RFC3986] that identifies the
	//   problem type. This specification encourages that, when
	//   dereferenced, it provide human-readable documentation for the
	//   problem type (e.g., using HTML [W3C.REC-html5-20141028]). When
	//   this member is not present, its value is assumed to be
	//   "about:blank".
	Type string `json:"type"`
	//   Title is a short, human-readable summary of the problem
	//   type. It SHOULD NOT change from occurrence to occurrence of the
	//   problem, except for purposes of localization (e.g., using
	//   proactive content negotiation; see [RFC7231], Section 3.4).
	Title string `json:"title"`
	//   Status is the HTTP status code ([RFC7231], Section 6)
	//   generated by the origin server for this occurrence of the problem.
	Status int `json:"status,omitempty"`
	//   Detail is a human-readable explanation specific to this
	//   occurrence of the problem. It is empty by default and
	//   it will not be marshalled if empty.
	Detail string `json:"detail,omitempty"`
	//   Instance is a URI reference that identifies the specific
	//   occurrence of the problem. It may or may not yield further
	//   information if dereferenced. It is empty by default and
	//   it will not be marshalled if empty.
	Instance string `json:"instance,omitempty"`

	Err error `json:"error,omitempty"`
}

func (p ProblemInfo) MarshalJSON() ([]byte, error) {
	type ProblemInfoAlias ProblemInfo
	type foo struct {
		ProblemInfoAlias
		ErrorText string `json:"error_text,omitempty"`
	}
	v := foo{
		ProblemInfoAlias: ProblemInfoAlias(p),
	}
	v.Type = *baseUrl.Load() + v.Type
	if p.Err != nil {
		v.ErrorText = p.Err.Error()
	}
	return json.Marshal(v)
}

func (p ProblemInfo) Error() string {
	if p.Err == nil {
		return "problem does not have an error"
	}
	return p.Err.Error()
}

func (p ProblemInfo) Problem() ProblemInfo {
	return p
}

func (p ProblemInfo) WithError(err error) ProblemInfo {
	p.Err = err
	return p
}

func (p ProblemInfo) WithDetails(instance, detail string) ProblemInfo {
	p.Detail = detail
	p.Instance = instance

	registerProblem(p)
	return p
}

func (p ProblemInfo) hasDetails() bool {
	return p.Detail != "" || p.Instance != ""
}

func (p ProblemInfo) withoutDetails() ProblemInfo {
	return ProblemInfo{
		Type:   p.Type,
		Title:  p.Title,
		Status: p.Status,
	}
}

func (p ProblemInfo) Is(err error) bool {
	o := AsProblem(err)
	op := o.Problem()
	if p.Status == op.Status && p.Type == op.Type {
		if p.Instance != "" && op.Instance != "" {
			return p.Instance == op.Instance
		}
		return true
	}

	return false
}

var baseUrl = atomic.Pointer[string]{}

func init() {
	def := "https://example.com/probs"
	baseUrl.Store(&def)
}

func SetBaseUrl(newBaseUrl string) {
	baseUrl.Store(&newBaseUrl)
}

func BaseUrl() string {
	return *baseUrl.Load()
}

func NewProblem(typePath, title string, status int) ProblemInfo {
	if !strings.HasPrefix(typePath, "/") {
		typePath = "/" + typePath
	}

	p := ProblemInfo{
		Type:   typePath,
		Title:  title,
		Status: status,
	}
	registerProblem(p)
	return p

}

func AsProblem(err error) Problem {
	for err != nil {
		if p, ok := err.(Problem); ok {
			return p
		}
		err = errors.Unwrap(err)
	}
	return nil
}
